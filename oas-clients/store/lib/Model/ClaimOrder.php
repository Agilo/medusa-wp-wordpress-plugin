<?php
/**
 * ClaimOrder
 *
 * PHP version 7.4
 *
 * @category Class
 * @package  MedusaWP\MedusaClient\Store
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Medusa Storefront API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 6.6.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace MedusaWP\MedusaClient\Store\Model;

use \ArrayAccess;
use \MedusaWP\MedusaClient\Store\ObjectSerializer;

/**
 * ClaimOrder Class Doc Comment
 *
 * @category Class
 * @description A Claim represents a group of faulty or missing items. It consists of claim items that refer to items in the original order that should be replaced or refunded. It also includes details related to shipping and fulfillment.
 * @package  MedusaWP\MedusaClient\Store
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 * @implements \ArrayAccess<string, mixed>
 */
class ClaimOrder implements ModelInterface, ArrayAccess, \JsonSerializable
{
    public const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $openAPIModelName = 'ClaimOrder';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPITypes = [
        'id' => 'string',
        'type' => 'string',
        'payment_status' => 'string',
        'fulfillment_status' => 'string',
        'claim_items' => '\MedusaWP\MedusaClient\Store\Model\ClaimItem[]',
        'additional_items' => '\MedusaWP\MedusaClient\Store\Model\LineItem[]',
        'order_id' => 'string',
        'order' => '\MedusaWP\MedusaClient\Store\Model\Order',
        'return_order' => '\MedusaWP\MedusaClient\Store\Model\ModelReturn',
        'shipping_address_id' => 'string',
        'shipping_address' => '\MedusaWP\MedusaClient\Store\Model\Address',
        'shipping_methods' => '\MedusaWP\MedusaClient\Store\Model\ShippingMethod[]',
        'fulfillments' => '\MedusaWP\MedusaClient\Store\Model\Fulfillment[]',
        'refund_amount' => 'int',
        'canceled_at' => '\DateTime',
        'created_at' => '\DateTime',
        'updated_at' => '\DateTime',
        'deleted_at' => '\DateTime',
        'metadata' => 'object',
        'no_notification' => 'bool',
        'idempotency_key' => 'string'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      * @phpstan-var array<string, string|null>
      * @psalm-var array<string, string|null>
      */
    protected static $openAPIFormats = [
        'id' => null,
        'type' => null,
        'payment_status' => null,
        'fulfillment_status' => null,
        'claim_items' => null,
        'additional_items' => null,
        'order_id' => null,
        'order' => null,
        'return_order' => null,
        'shipping_address_id' => null,
        'shipping_address' => null,
        'shipping_methods' => null,
        'fulfillments' => null,
        'refund_amount' => null,
        'canceled_at' => 'date-time',
        'created_at' => 'date-time',
        'updated_at' => 'date-time',
        'deleted_at' => 'date-time',
        'metadata' => null,
        'no_notification' => null,
        'idempotency_key' => null
    ];

    /**
      * Array of nullable properties. Used for (de)serialization
      *
      * @var boolean[]
      */
    protected static array $openAPINullables = [
        'id' => false,
		'type' => false,
		'payment_status' => false,
		'fulfillment_status' => false,
		'claim_items' => false,
		'additional_items' => false,
		'order_id' => false,
		'order' => false,
		'return_order' => false,
		'shipping_address_id' => true,
		'shipping_address' => false,
		'shipping_methods' => false,
		'fulfillments' => false,
		'refund_amount' => true,
		'canceled_at' => true,
		'created_at' => false,
		'updated_at' => false,
		'deleted_at' => true,
		'metadata' => true,
		'no_notification' => true,
		'idempotency_key' => true
    ];

    /**
      * If a nullable field gets set to null, insert it here
      *
      * @var boolean[]
      */
    protected array $openAPINullablesSetToNull = [];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPITypes()
    {
        return self::$openAPITypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPIFormats()
    {
        return self::$openAPIFormats;
    }

    /**
     * Array of nullable properties
     *
     * @return array
     */
    protected static function openAPINullables(): array
    {
        return self::$openAPINullables;
    }

    /**
     * Array of nullable field names deliberately set to null
     *
     * @return boolean[]
     */
    private function getOpenAPINullablesSetToNull(): array
    {
        return $this->openAPINullablesSetToNull;
    }

    /**
     * Setter - Array of nullable field names deliberately set to null
     *
     * @param boolean[] $openAPINullablesSetToNull
     */
    private function setOpenAPINullablesSetToNull(array $openAPINullablesSetToNull): void
    {
        $this->openAPINullablesSetToNull = $openAPINullablesSetToNull;
    }

    /**
     * Checks if a property is nullable
     *
     * @param string $property
     * @return bool
     */
    public static function isNullable(string $property): bool
    {
        return self::openAPINullables()[$property] ?? false;
    }

    /**
     * Checks if a nullable property is set to null.
     *
     * @param string $property
     * @return bool
     */
    public function isNullableSetToNull(string $property): bool
    {
        return in_array($property, $this->getOpenAPINullablesSetToNull(), true);
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'id' => 'id',
        'type' => 'type',
        'payment_status' => 'payment_status',
        'fulfillment_status' => 'fulfillment_status',
        'claim_items' => 'claim_items',
        'additional_items' => 'additional_items',
        'order_id' => 'order_id',
        'order' => 'order',
        'return_order' => 'return_order',
        'shipping_address_id' => 'shipping_address_id',
        'shipping_address' => 'shipping_address',
        'shipping_methods' => 'shipping_methods',
        'fulfillments' => 'fulfillments',
        'refund_amount' => 'refund_amount',
        'canceled_at' => 'canceled_at',
        'created_at' => 'created_at',
        'updated_at' => 'updated_at',
        'deleted_at' => 'deleted_at',
        'metadata' => 'metadata',
        'no_notification' => 'no_notification',
        'idempotency_key' => 'idempotency_key'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'id' => 'setId',
        'type' => 'setType',
        'payment_status' => 'setPaymentStatus',
        'fulfillment_status' => 'setFulfillmentStatus',
        'claim_items' => 'setClaimItems',
        'additional_items' => 'setAdditionalItems',
        'order_id' => 'setOrderId',
        'order' => 'setOrder',
        'return_order' => 'setReturnOrder',
        'shipping_address_id' => 'setShippingAddressId',
        'shipping_address' => 'setShippingAddress',
        'shipping_methods' => 'setShippingMethods',
        'fulfillments' => 'setFulfillments',
        'refund_amount' => 'setRefundAmount',
        'canceled_at' => 'setCanceledAt',
        'created_at' => 'setCreatedAt',
        'updated_at' => 'setUpdatedAt',
        'deleted_at' => 'setDeletedAt',
        'metadata' => 'setMetadata',
        'no_notification' => 'setNoNotification',
        'idempotency_key' => 'setIdempotencyKey'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'id' => 'getId',
        'type' => 'getType',
        'payment_status' => 'getPaymentStatus',
        'fulfillment_status' => 'getFulfillmentStatus',
        'claim_items' => 'getClaimItems',
        'additional_items' => 'getAdditionalItems',
        'order_id' => 'getOrderId',
        'order' => 'getOrder',
        'return_order' => 'getReturnOrder',
        'shipping_address_id' => 'getShippingAddressId',
        'shipping_address' => 'getShippingAddress',
        'shipping_methods' => 'getShippingMethods',
        'fulfillments' => 'getFulfillments',
        'refund_amount' => 'getRefundAmount',
        'canceled_at' => 'getCanceledAt',
        'created_at' => 'getCreatedAt',
        'updated_at' => 'getUpdatedAt',
        'deleted_at' => 'getDeletedAt',
        'metadata' => 'getMetadata',
        'no_notification' => 'getNoNotification',
        'idempotency_key' => 'getIdempotencyKey'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$openAPIModelName;
    }

    public const TYPE_REFUND = 'refund';
    public const TYPE_REPLACE = 'replace';
    public const PAYMENT_STATUS_NA = 'na';
    public const PAYMENT_STATUS_NOT_REFUNDED = 'not_refunded';
    public const PAYMENT_STATUS_REFUNDED = 'refunded';
    public const FULFILLMENT_STATUS_NOT_FULFILLED = 'not_fulfilled';
    public const FULFILLMENT_STATUS_PARTIALLY_FULFILLED = 'partially_fulfilled';
    public const FULFILLMENT_STATUS_FULFILLED = 'fulfilled';
    public const FULFILLMENT_STATUS_PARTIALLY_SHIPPED = 'partially_shipped';
    public const FULFILLMENT_STATUS_SHIPPED = 'shipped';
    public const FULFILLMENT_STATUS_PARTIALLY_RETURNED = 'partially_returned';
    public const FULFILLMENT_STATUS_RETURNED = 'returned';
    public const FULFILLMENT_STATUS_CANCELED = 'canceled';
    public const FULFILLMENT_STATUS_REQUIRES_ACTION = 'requires_action';

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getTypeAllowableValues()
    {
        return [
            self::TYPE_REFUND,
            self::TYPE_REPLACE,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getPaymentStatusAllowableValues()
    {
        return [
            self::PAYMENT_STATUS_NA,
            self::PAYMENT_STATUS_NOT_REFUNDED,
            self::PAYMENT_STATUS_REFUNDED,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getFulfillmentStatusAllowableValues()
    {
        return [
            self::FULFILLMENT_STATUS_NOT_FULFILLED,
            self::FULFILLMENT_STATUS_PARTIALLY_FULFILLED,
            self::FULFILLMENT_STATUS_FULFILLED,
            self::FULFILLMENT_STATUS_PARTIALLY_SHIPPED,
            self::FULFILLMENT_STATUS_SHIPPED,
            self::FULFILLMENT_STATUS_PARTIALLY_RETURNED,
            self::FULFILLMENT_STATUS_RETURNED,
            self::FULFILLMENT_STATUS_CANCELED,
            self::FULFILLMENT_STATUS_REQUIRES_ACTION,
        ];
    }

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->setIfExists('id', $data ?? [], null);
        $this->setIfExists('type', $data ?? [], null);
        $this->setIfExists('payment_status', $data ?? [], 'na');
        $this->setIfExists('fulfillment_status', $data ?? [], 'not_fulfilled');
        $this->setIfExists('claim_items', $data ?? [], null);
        $this->setIfExists('additional_items', $data ?? [], null);
        $this->setIfExists('order_id', $data ?? [], null);
        $this->setIfExists('order', $data ?? [], null);
        $this->setIfExists('return_order', $data ?? [], null);
        $this->setIfExists('shipping_address_id', $data ?? [], null);
        $this->setIfExists('shipping_address', $data ?? [], null);
        $this->setIfExists('shipping_methods', $data ?? [], null);
        $this->setIfExists('fulfillments', $data ?? [], null);
        $this->setIfExists('refund_amount', $data ?? [], null);
        $this->setIfExists('canceled_at', $data ?? [], null);
        $this->setIfExists('created_at', $data ?? [], null);
        $this->setIfExists('updated_at', $data ?? [], null);
        $this->setIfExists('deleted_at', $data ?? [], null);
        $this->setIfExists('metadata', $data ?? [], null);
        $this->setIfExists('no_notification', $data ?? [], null);
        $this->setIfExists('idempotency_key', $data ?? [], null);
    }

    /**
    * Sets $this->container[$variableName] to the given data or to the given default Value; if $variableName
    * is nullable and its value is set to null in the $fields array, then mark it as "set to null" in the
    * $this->openAPINullablesSetToNull array
    *
    * @param string $variableName
    * @param array  $fields
    * @param mixed  $defaultValue
    */
    private function setIfExists(string $variableName, array $fields, $defaultValue): void
    {
        if (self::isNullable($variableName) && array_key_exists($variableName, $fields) && is_null($fields[$variableName])) {
            $this->openAPINullablesSetToNull[] = $variableName;
        }

        $this->container[$variableName] = $fields[$variableName] ?? $defaultValue;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        if ($this->container['id'] === null) {
            $invalidProperties[] = "'id' can't be null";
        }
        if ($this->container['type'] === null) {
            $invalidProperties[] = "'type' can't be null";
        }
        $allowedValues = $this->getTypeAllowableValues();
        if (!is_null($this->container['type']) && !in_array($this->container['type'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'type', must be one of '%s'",
                $this->container['type'],
                implode("', '", $allowedValues)
            );
        }

        if ($this->container['payment_status'] === null) {
            $invalidProperties[] = "'payment_status' can't be null";
        }
        $allowedValues = $this->getPaymentStatusAllowableValues();
        if (!is_null($this->container['payment_status']) && !in_array($this->container['payment_status'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'payment_status', must be one of '%s'",
                $this->container['payment_status'],
                implode("', '", $allowedValues)
            );
        }

        if ($this->container['fulfillment_status'] === null) {
            $invalidProperties[] = "'fulfillment_status' can't be null";
        }
        $allowedValues = $this->getFulfillmentStatusAllowableValues();
        if (!is_null($this->container['fulfillment_status']) && !in_array($this->container['fulfillment_status'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'fulfillment_status', must be one of '%s'",
                $this->container['fulfillment_status'],
                implode("', '", $allowedValues)
            );
        }

        if ($this->container['order_id'] === null) {
            $invalidProperties[] = "'order_id' can't be null";
        }
        if ($this->container['shipping_address_id'] === null) {
            $invalidProperties[] = "'shipping_address_id' can't be null";
        }
        if ($this->container['refund_amount'] === null) {
            $invalidProperties[] = "'refund_amount' can't be null";
        }
        if ($this->container['canceled_at'] === null) {
            $invalidProperties[] = "'canceled_at' can't be null";
        }
        if ($this->container['created_at'] === null) {
            $invalidProperties[] = "'created_at' can't be null";
        }
        if ($this->container['updated_at'] === null) {
            $invalidProperties[] = "'updated_at' can't be null";
        }
        if ($this->container['deleted_at'] === null) {
            $invalidProperties[] = "'deleted_at' can't be null";
        }
        if ($this->container['metadata'] === null) {
            $invalidProperties[] = "'metadata' can't be null";
        }
        if ($this->container['no_notification'] === null) {
            $invalidProperties[] = "'no_notification' can't be null";
        }
        if ($this->container['idempotency_key'] === null) {
            $invalidProperties[] = "'idempotency_key' can't be null";
        }
        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets id
     *
     * @return string
     */
    public function getId()
    {
        return $this->container['id'];
    }

    /**
     * Sets id
     *
     * @param string $id The claim's ID
     *
     * @return self
     */
    public function setId($id)
    {
        if (is_null($id)) {
            throw new \InvalidArgumentException('non-nullable id cannot be null');
        }
        $this->container['id'] = $id;

        return $this;
    }

    /**
     * Gets type
     *
     * @return string
     */
    public function getType()
    {
        return $this->container['type'];
    }

    /**
     * Sets type
     *
     * @param string $type The claim's type
     *
     * @return self
     */
    public function setType($type)
    {
        if (is_null($type)) {
            throw new \InvalidArgumentException('non-nullable type cannot be null');
        }
        $allowedValues = $this->getTypeAllowableValues();
        if (!in_array($type, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'type', must be one of '%s'",
                    $type,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['type'] = $type;

        return $this;
    }

    /**
     * Gets payment_status
     *
     * @return string
     */
    public function getPaymentStatus()
    {
        return $this->container['payment_status'];
    }

    /**
     * Sets payment_status
     *
     * @param string $payment_status The status of the claim's payment
     *
     * @return self
     */
    public function setPaymentStatus($payment_status)
    {
        if (is_null($payment_status)) {
            throw new \InvalidArgumentException('non-nullable payment_status cannot be null');
        }
        $allowedValues = $this->getPaymentStatusAllowableValues();
        if (!in_array($payment_status, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'payment_status', must be one of '%s'",
                    $payment_status,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['payment_status'] = $payment_status;

        return $this;
    }

    /**
     * Gets fulfillment_status
     *
     * @return string
     */
    public function getFulfillmentStatus()
    {
        return $this->container['fulfillment_status'];
    }

    /**
     * Sets fulfillment_status
     *
     * @param string $fulfillment_status The claim's fulfillment status
     *
     * @return self
     */
    public function setFulfillmentStatus($fulfillment_status)
    {
        if (is_null($fulfillment_status)) {
            throw new \InvalidArgumentException('non-nullable fulfillment_status cannot be null');
        }
        $allowedValues = $this->getFulfillmentStatusAllowableValues();
        if (!in_array($fulfillment_status, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'fulfillment_status', must be one of '%s'",
                    $fulfillment_status,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['fulfillment_status'] = $fulfillment_status;

        return $this;
    }

    /**
     * Gets claim_items
     *
     * @return \MedusaWP\MedusaClient\Store\Model\ClaimItem[]|null
     */
    public function getClaimItems()
    {
        return $this->container['claim_items'];
    }

    /**
     * Sets claim_items
     *
     * @param \MedusaWP\MedusaClient\Store\Model\ClaimItem[]|null $claim_items The details of the items that should be replaced or refunded.
     *
     * @return self
     */
    public function setClaimItems($claim_items)
    {
        if (is_null($claim_items)) {
            throw new \InvalidArgumentException('non-nullable claim_items cannot be null');
        }
        $this->container['claim_items'] = $claim_items;

        return $this;
    }

    /**
     * Gets additional_items
     *
     * @return \MedusaWP\MedusaClient\Store\Model\LineItem[]|null
     */
    public function getAdditionalItems()
    {
        return $this->container['additional_items'];
    }

    /**
     * Sets additional_items
     *
     * @param \MedusaWP\MedusaClient\Store\Model\LineItem[]|null $additional_items The details of the new items to be shipped when the claim's type is `replace`
     *
     * @return self
     */
    public function setAdditionalItems($additional_items)
    {
        if (is_null($additional_items)) {
            throw new \InvalidArgumentException('non-nullable additional_items cannot be null');
        }
        $this->container['additional_items'] = $additional_items;

        return $this;
    }

    /**
     * Gets order_id
     *
     * @return string
     */
    public function getOrderId()
    {
        return $this->container['order_id'];
    }

    /**
     * Sets order_id
     *
     * @param string $order_id The ID of the order that the claim comes from.
     *
     * @return self
     */
    public function setOrderId($order_id)
    {
        if (is_null($order_id)) {
            throw new \InvalidArgumentException('non-nullable order_id cannot be null');
        }
        $this->container['order_id'] = $order_id;

        return $this;
    }

    /**
     * Gets order
     *
     * @return \MedusaWP\MedusaClient\Store\Model\Order|null
     */
    public function getOrder()
    {
        return $this->container['order'];
    }

    /**
     * Sets order
     *
     * @param \MedusaWP\MedusaClient\Store\Model\Order|null $order order
     *
     * @return self
     */
    public function setOrder($order)
    {
        if (is_null($order)) {
            throw new \InvalidArgumentException('non-nullable order cannot be null');
        }
        $this->container['order'] = $order;

        return $this;
    }

    /**
     * Gets return_order
     *
     * @return \MedusaWP\MedusaClient\Store\Model\ModelReturn|null
     */
    public function getReturnOrder()
    {
        return $this->container['return_order'];
    }

    /**
     * Sets return_order
     *
     * @param \MedusaWP\MedusaClient\Store\Model\ModelReturn|null $return_order return_order
     *
     * @return self
     */
    public function setReturnOrder($return_order)
    {
        if (is_null($return_order)) {
            throw new \InvalidArgumentException('non-nullable return_order cannot be null');
        }
        $this->container['return_order'] = $return_order;

        return $this;
    }

    /**
     * Gets shipping_address_id
     *
     * @return string
     */
    public function getShippingAddressId()
    {
        return $this->container['shipping_address_id'];
    }

    /**
     * Sets shipping_address_id
     *
     * @param string $shipping_address_id The ID of the address that the new items should be shipped to
     *
     * @return self
     */
    public function setShippingAddressId($shipping_address_id)
    {
        if (is_null($shipping_address_id)) {
            array_push($this->openAPINullablesSetToNull, 'shipping_address_id');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('shipping_address_id', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['shipping_address_id'] = $shipping_address_id;

        return $this;
    }

    /**
     * Gets shipping_address
     *
     * @return \MedusaWP\MedusaClient\Store\Model\Address|null
     */
    public function getShippingAddress()
    {
        return $this->container['shipping_address'];
    }

    /**
     * Sets shipping_address
     *
     * @param \MedusaWP\MedusaClient\Store\Model\Address|null $shipping_address shipping_address
     *
     * @return self
     */
    public function setShippingAddress($shipping_address)
    {
        if (is_null($shipping_address)) {
            throw new \InvalidArgumentException('non-nullable shipping_address cannot be null');
        }
        $this->container['shipping_address'] = $shipping_address;

        return $this;
    }

    /**
     * Gets shipping_methods
     *
     * @return \MedusaWP\MedusaClient\Store\Model\ShippingMethod[]|null
     */
    public function getShippingMethods()
    {
        return $this->container['shipping_methods'];
    }

    /**
     * Sets shipping_methods
     *
     * @param \MedusaWP\MedusaClient\Store\Model\ShippingMethod[]|null $shipping_methods The details of the shipping methods that the claim order will be shipped with.
     *
     * @return self
     */
    public function setShippingMethods($shipping_methods)
    {
        if (is_null($shipping_methods)) {
            throw new \InvalidArgumentException('non-nullable shipping_methods cannot be null');
        }
        $this->container['shipping_methods'] = $shipping_methods;

        return $this;
    }

    /**
     * Gets fulfillments
     *
     * @return \MedusaWP\MedusaClient\Store\Model\Fulfillment[]|null
     */
    public function getFulfillments()
    {
        return $this->container['fulfillments'];
    }

    /**
     * Sets fulfillments
     *
     * @param \MedusaWP\MedusaClient\Store\Model\Fulfillment[]|null $fulfillments The fulfillments of the new items to be shipped
     *
     * @return self
     */
    public function setFulfillments($fulfillments)
    {
        if (is_null($fulfillments)) {
            throw new \InvalidArgumentException('non-nullable fulfillments cannot be null');
        }
        $this->container['fulfillments'] = $fulfillments;

        return $this;
    }

    /**
     * Gets refund_amount
     *
     * @return int
     */
    public function getRefundAmount()
    {
        return $this->container['refund_amount'];
    }

    /**
     * Sets refund_amount
     *
     * @param int $refund_amount The amount that will be refunded in conjunction with the claim
     *
     * @return self
     */
    public function setRefundAmount($refund_amount)
    {
        if (is_null($refund_amount)) {
            array_push($this->openAPINullablesSetToNull, 'refund_amount');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('refund_amount', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['refund_amount'] = $refund_amount;

        return $this;
    }

    /**
     * Gets canceled_at
     *
     * @return \DateTime
     */
    public function getCanceledAt()
    {
        return $this->container['canceled_at'];
    }

    /**
     * Sets canceled_at
     *
     * @param \DateTime $canceled_at The date with timezone at which the claim was canceled.
     *
     * @return self
     */
    public function setCanceledAt($canceled_at)
    {
        if (is_null($canceled_at)) {
            array_push($this->openAPINullablesSetToNull, 'canceled_at');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('canceled_at', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['canceled_at'] = $canceled_at;

        return $this;
    }

    /**
     * Gets created_at
     *
     * @return \DateTime
     */
    public function getCreatedAt()
    {
        return $this->container['created_at'];
    }

    /**
     * Sets created_at
     *
     * @param \DateTime $created_at The date with timezone at which the resource was created.
     *
     * @return self
     */
    public function setCreatedAt($created_at)
    {
        if (is_null($created_at)) {
            throw new \InvalidArgumentException('non-nullable created_at cannot be null');
        }
        $this->container['created_at'] = $created_at;

        return $this;
    }

    /**
     * Gets updated_at
     *
     * @return \DateTime
     */
    public function getUpdatedAt()
    {
        return $this->container['updated_at'];
    }

    /**
     * Sets updated_at
     *
     * @param \DateTime $updated_at The date with timezone at which the resource was updated.
     *
     * @return self
     */
    public function setUpdatedAt($updated_at)
    {
        if (is_null($updated_at)) {
            throw new \InvalidArgumentException('non-nullable updated_at cannot be null');
        }
        $this->container['updated_at'] = $updated_at;

        return $this;
    }

    /**
     * Gets deleted_at
     *
     * @return \DateTime
     */
    public function getDeletedAt()
    {
        return $this->container['deleted_at'];
    }

    /**
     * Sets deleted_at
     *
     * @param \DateTime $deleted_at The date with timezone at which the resource was deleted.
     *
     * @return self
     */
    public function setDeletedAt($deleted_at)
    {
        if (is_null($deleted_at)) {
            array_push($this->openAPINullablesSetToNull, 'deleted_at');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('deleted_at', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['deleted_at'] = $deleted_at;

        return $this;
    }

    /**
     * Gets metadata
     *
     * @return object
     */
    public function getMetadata()
    {
        return $this->container['metadata'];
    }

    /**
     * Sets metadata
     *
     * @param object $metadata An optional key-value map with additional details
     *
     * @return self
     */
    public function setMetadata($metadata)
    {
        if (is_null($metadata)) {
            array_push($this->openAPINullablesSetToNull, 'metadata');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('metadata', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['metadata'] = $metadata;

        return $this;
    }

    /**
     * Gets no_notification
     *
     * @return bool
     */
    public function getNoNotification()
    {
        return $this->container['no_notification'];
    }

    /**
     * Sets no_notification
     *
     * @param bool $no_notification Flag for describing whether or not notifications related to this should be send.
     *
     * @return self
     */
    public function setNoNotification($no_notification)
    {
        if (is_null($no_notification)) {
            array_push($this->openAPINullablesSetToNull, 'no_notification');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('no_notification', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['no_notification'] = $no_notification;

        return $this;
    }

    /**
     * Gets idempotency_key
     *
     * @return string
     */
    public function getIdempotencyKey()
    {
        return $this->container['idempotency_key'];
    }

    /**
     * Sets idempotency_key
     *
     * @param string $idempotency_key Randomly generated key used to continue the completion of the cart associated with the claim in case of failure.
     *
     * @return self
     */
    public function setIdempotencyKey($idempotency_key)
    {
        if (is_null($idempotency_key)) {
            array_push($this->openAPINullablesSetToNull, 'idempotency_key');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('idempotency_key', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['idempotency_key'] = $idempotency_key;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset): bool
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed|null
     */
    #[\ReturnTypeWillChange]
    public function offsetGet($offset)
    {
        return $this->container[$offset] ?? null;
    }

    /**
     * Sets value based on offset.
     *
     * @param int|null $offset Offset
     * @param mixed    $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value): void
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset): void
    {
        unset($this->container[$offset]);
    }

    /**
     * Serializes the object to a value that can be serialized natively by json_encode().
     * @link https://www.php.net/manual/en/jsonserializable.jsonserialize.php
     *
     * @return mixed Returns data which can be serialized by json_encode(), which is a value
     * of any type other than a resource.
     */
    #[\ReturnTypeWillChange]
    public function jsonSerialize()
    {
       return ObjectSerializer::sanitizeForSerialization($this);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        return json_encode(
            ObjectSerializer::sanitizeForSerialization($this),
            JSON_PRETTY_PRINT
        );
    }

    /**
     * Gets a header-safe presentation of the object
     *
     * @return string
     */
    public function toHeaderValue()
    {
        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


